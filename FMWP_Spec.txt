[기능 요구 명세서] FMWP — DART Open API 기반 Raw 적재 + 3-Statement Model 생성
대상 리포지토리: https://github.com/Moonyoung-Choi-git/Financial-Modeling
작성일: 2026-01-29 (Asia/Seoul)

1) 목표/배경
- (1단계) DART Open API로 “실제” 데이터를 수집하여 Raw Table Database에 “감사 가능(Auditable) / 재현 가능(Reproducible) / 불변(Immutable)” 형태로 저장한다.
- (2단계) 사용자가 “종목코드(6자리)”를 입력하면, 이를 금융감독원전자공시시스템(이하 DART)의 기업코드로 변환하고 해당 기업의 3-Statement(재무상태표/손익(포괄손익)/현금흐름) 모델을 자동 생성한다.

2) 현재 시스템(리포) 구조/가정(관찰 기반)
- Next.js(App Router) + API Routes 기반의 웹 플랫폼 구조를 사용한다.
- DB는 PostgreSQL, 큐/캐시는 Redis + BullMQ를 사용하며 worker 프로세스(worker.ts)가 존재한다.
- Prisma 스키마(schema.prisma)와 seed 스크립트(seed.ts)가 존재하므로, “정규 테이블 + Raw 테이블”을 Prisma 모델로 운영할 가능성이 높다.
- 본 요구서는 “이미 존재하는 Raw 적재/불변성 패턴(테이블 네이밍, ID, 해시, 버전 관리 등)”이 있다면 그 구현 방식을 최우선으로 재사용하도록 설계한다.

3) 용어 정의
- stock_code: 거래소 종목코드(6자리). 사용자 입력 키.
- corp_code: DART 고유번호(8자리). API 조회 키.
- rcept_no: 공시 접수번호(14자리). 공시 문서/재무데이터 연결 키.
- reprt_code: 보고서 코드(11013/11012/11014/11011).
- fs_div: 재무제표 구분(OFS: 개별, CFS: 연결).
- sj_div: 재무제표 구분(BS/IS/CIS/CF/SCE).
- Raw Table: “API 응답 원형(또는 원형에 준하는 최소 가공)”을 보관하는 테이블. 변경 불가(append-only) 원칙.
- Normalized/Fact Table: 모델 생성 및 조회 성능을 위해 Raw에서 파생되는 정규화 테이블.
- 3-Statement Model: 특정 기간(연/분기)의 BS/IS(or CIS)/CF를 일관된 라인아이템 체계로 구성한 결과물.

4) 범위(Scope)
4.1 반드시 포함(Must)
A. corp_code 마스터 동기화(고유번호 ZIP/XML 다운로드 → 파싱 → DB 적재)
B. 종목코드(stock_code) → corp_code 매핑 및 검증(회사개황/company API 활용 포함)
C. 재무제표 데이터 수집(단일회사 재무제표: sj_div 포함)
D. Raw Table Database 저장(요청/응답 메타 포함 + 불변성 + 중복/버전 처리)
E. 종목코드 입력 → 3-Statement Model 생성(최소: 최근 N개 연도, 또는 최근 4~8개 분기)
F. 작업 큐 기반 비동기 적재/재시도/레이트리밋 대응(Worker + BullMQ)
G. 감사/재현성: “어떤 API 호출로 어떤 데이터가 생성되었는지” 추적 가능해야 함

4.2 선택(Optional / 후순위)
- 공시서류 원본(document.xml) ZIP 저장(재무 숫자 검증/감사 추적 강화용)
- XBRL 원문 다운로드 및 주석/세부 공시 파싱
- 회사간 비교/지표 계산/시나리오 모델링 UI

5) 외부 인터페이스 요구사항(DART Open API)
5.1 corpCode(고유번호) 동기화
- Endpoint: /api/corpCode.xml (ZIP binary)
- 입력: crtfc_key
- 출력(XML inside ZIP): corp_code, corp_name, corp_eng_name, stock_code, modify_date
- 요구사항:
  - ZIP binary 다운로드 후 압축해제 → XML 파싱 → 레코드 단위 upsert
  - “스냅샷” 개념 지원: 전체 파일 기반의 버전/수집시점(run_id) 관리(추후 변경 추적)
  - modify_date를 이용해 변경 감지/갱신 정책을 수립(전체 리프레시 vs 증분)
  - 오류코드(예: 020 요청 제한 초과) 발생 시 백오프/재시도 정책 적용

5.2 company(기업개황) 조회/캐시
- Endpoint: /api/company.json
- 입력: crtfc_key, corp_code
- 출력: corp_name, stock_code, corp_cls 등 회사 메타
- 요구사항:
  - corp_code ↔ stock_code 매핑 검증(상장사인 경우 stock_code 존재해야 함)
  - corp_cls(유가/코스닥/코넥스/기타) 기반 필터링 옵션 제공(모델 생성 대상 제어)

5.3 list(공시검색) — 메타 적재
- Endpoint: /api/list.json
- 입력: crtfc_key + (corp_code, bgn_de, end_de, page_no, page_count 등)
- 출력: 공시 목록(corp_code, stock_code, report_nm, rcept_no, flr_nm 등)
- 요구사항:
  - (선택) 재무데이터와 “접수번호(rcept_no)”로 연결하기 위해 공시 메타를 Raw로 보관
  - 증분 수집을 위해 bgn_de/end_de 기준 last_success_at를 관리

5.4 fnlttSinglAcntAll(단일회사 재무제표 조회)
- Endpoint: (정기보고서 재무정보 그룹) 단일회사 재무제표 조회 API
- 입력: crtfc_key, corp_code, bsns_year, reprt_code, fs_div
- 출력(list row): rcept_no, sj_div(BS/IS/CIS/CF/SCE), account_id, account_nm, thstrm_amount, thstrm_add_amount, frmtrm_amount, bfefrmtrm_amount, currency, ord 등
- 요구사항:
  - 최소 지원: BS + (IS 또는 CIS) + CF
  - 보고서 코드(reprt_code)별 기간 해석 규칙을 명시(분기/반기/연간)
  - 연결/개별(fs_div) 우선순위 정책 제공(기본: CFS 우선, 없으면 OFS fallback)

5.5 document(공시서류원본파일) — 감사 강화(선택)
- Endpoint: /api/document.xml (ZIP binary)
- 입력: crtfc_key, rcept_no
- 요구사항:
  - 법적/감사 추적 목적: “모델에 쓰인 rcept_no의 원문 ZIP”을 옵션으로 저장
  - 저장 용량/비용을 고려해 보관 정책(최근 N개만, 또는 on-demand)을 설정

6) 시스템 기능 요구사항(Backend/API/Worker)
6.1 인증키/환경설정
- DART API 인증키는 .env/Secret Manager로 관리(로그/응답에 노출 금지)
- 운영환경에서 키 교체/폐기(rotate) 가능해야 함

6.2 수집 파이프라인(ETL) — 공통
- 모든 DART 호출은 다음 메타를 표준화하여 저장:
  - provider = “DART”
  - endpoint_name (corpCode/list/company/fnltt/document 등)
  - request_params(민감정보 마스킹), request_url
  - http_status, DART status/message, fetched_at
  - raw_payload(JSON/XML/ZIP bytes) 또는 payload_hash + object storage 경로
- “원천 데이터 불변성”:
  - Raw 테이블은 원칙적으로 UPDATE 금지(append-only)
  - 동일 키(예: corp_code+year+reprt_code+fs_div) 재수집 시 “새 run_id로 추가”하고, 최신본을 가리키는 뷰/포인터만 갱신(정규 테이블에서)
- 중복 방지:
  - (권장) payload_hash(sha256 등) 기반 dedupe(동일 응답 중복 저장 방지)
  - 단, 감사 목적상 “호출 로그”는 중복이어도 남기되, payload blob은 dedupe 가능

6.3 BullMQ 기반 작업 설계
- Queue Job 타입(예시):
  - SyncCorpCodeJob
  - SyncCompanyProfileJob(corp_code)
  - SyncDisclosureListJob(corp_code, date_range)
  - SyncFinancialStatementsJob(corp_code, years[], reprt_codes[], fs_div)
  - BuildThreeStatementModelJob(stock_code, options)
- 공통 정책:
  - 재시도: DART 오류코드/HTTP에 따라 분기(예: 020/429는 백오프)
  - 동시성 제한: provider별 rate limiter(전역/worker 단위)
  - idempotency: 동일 job_key는 “중복 실행되어도 결과가 일관”해야 함

6.4 API Routes(서버) 기능
- (필수) POST /api/model/three-statement/build
  - 입력: stock_code, (옵션) years_back, fs_div_preference(CFS-first), reprt_scope(annual-only vs quarterly)
  - 처리: (1) corp_code 확인/없으면 corpCode sync 유도 → (2) 재무데이터 없으면 수집 job enqueue → (3) 모델 생성 job enqueue/또는 동기 처리 → (4) job_id/상태 반환
- (필수) GET /api/model/three-statement/status?job_id=...
  - 처리: 진행률/에러/완료 결과 링크 제공
- (관리자/운영) POST /api/admin/dart/sync-corp-codes
  - 처리: corpCode 전체 동기화 실행(스케줄러/수동 트리거)
- (관리자/운영) POST /api/admin/dart/sync-financials?stock_code=...
  - 처리: 특정 기업의 재무데이터 재수집/갱신

6.5 UI 요구(최소)
- 종목코드 입력 폼 + 생성 버튼
- 진행상태(job) 표시(큐 대기/수집 중/모델링 중/완료/실패)
- 완료 시 3-Statement 뷰:
  - 기간 선택(연/분기)
  - 재무제표 탭(BS, IS/CIS, CF)
  - 원천 추적(각 기간별 rcept_no / 호출 run_id / fs_div / reprt_code 표시)

7) 데이터 모델 요구사항(DB 설계: Raw + Normalized + Model)
※ 실제 테이블/모델명은 기존 schema.prisma 패턴에 맞춰 확정한다(아래는 요구 엔티티 정의).

7.1 Raw 영역(필수)
A. raw_api_call (호출 로그)
- pk: id
- provider, endpoint_name
- request_params_json(마스킹), request_fingerprint(정렬/정규화된 파라미터 해시)
- fetched_at, http_status, dart_status, dart_message
- payload_type(JSON/XML/ZIP), payload_hash, payload_storage_ref(또는 inline JSONB)
- duration_ms, retry_count, job_id, run_id

B. raw_corp_code_snapshot / raw_corp_code_row
- snapshot(run_id, fetched_at, payload_hash, record_count)
- row(corp_code, stock_code, corp_name, corp_eng_name, modify_date, snapshot_run_id)

C. raw_company_profile
- corp_code, fetched_at, payload_hash
- response_jsonb(원형)
- 주요 필드는 컬럼으로도 뽑아 인덱스(예: corp_cls, stock_code)

D. raw_disclosure_list_item
- corp_code, rcept_no, report_nm, rcept_dt, stock_code, corp_cls 등
- fetched_at/run_id + 원형 JSON 저장

E. raw_financial_statement_row
- corp_code, bsns_year, reprt_code, fs_div
- rcept_no, sj_div, sj_nm
- account_id, account_nm, account_detail
- thstrm_nm, thstrm_amount, thstrm_add_amount
- frmtrm_nm, frmtrm_amount, frmtrm_q_nm, frmtrm_q_amount, frmtrm_add_amount
- bfefrmtrm_nm, bfefrmtrm_amount
- currency, ord
- run_id, fetched_at, payload_hash(또는 상위 호출과의 FK)

F. raw_document_blob (선택)
- rcept_no, fetched_at, payload_hash, storage_ref(zip), run_id

7.2 Normalized/Fact 영역(필수)
A. corp_master
- corp_code(PK), stock_code(unique), corp_name, corp_cls, last_synced_at
- corpCode/company 기반으로 업데이트하되, 원천 추적(run_id)을 유지

B. fs_fact
- corp_code, period_key(예: 2024Q4/2024FY), fs_div, statement_type(BS/IS/CIS/CF)
- line_item_key(표준 라인아이템), source_account_id, source_account_nm
- amount_numeric, currency, unit
- source_run_id, source_rcept_no, source_repr_code
- (중요) raw → fact 변환 규칙 버전(rule_version) 저장

C. three_statement_model
- model_id, corp_code, created_at, options_json
- 범위(기간 리스트), 사용한 fs_div 우선순위/실제 선택 결과
- 생성 결과 요약(라인아이템 수, 누락 수, 검증 결과)

D. three_statement_model_line
- model_id, period_key, statement_type, line_item_key, amount
- provenance: source_run_id, source_row_id(또는 account_id+sj_div+period 매핑)

8) 3-Statement Model 생성 규칙(핵심 로직 요구)
8.1 입력/출력
- 입력: stock_code(6자리) + 옵션(years_back, quarterly 여부, fs_div 우선순위)
- 출력:
  - period 별 BS/IS(or CIS)/CF의 표준 라인아이템 집합
  - 원천 추적(각 값이 어느 DART row에서 왔는지)

8.2 기간/보고서 코드 해석
- reprt_code 매핑:
  - 11013: 1분기
  - 11012: 반기
  - 11014: 3분기
  - 11011: 사업보고서(연간)
- 분/반기 손익계정은 “당기금액(3개월)”과 “누적금액”이 모두 존재할 수 있으므로,
  - quarterly 모델: thstrm_amount(3개월) 우선 사용, 누적은 검증/보조로 사용
  - YTD 모델: thstrm_add_amount 사용
  - 연간(FY) 모델: 사업보고서(11011)의 금액 사용

8.3 연결/개별 선택(fs_div)
- 기본 정책:
  - 1순위 CFS(연결) → 없으면 OFS(개별)
  - 단, 사용자 옵션으로 OFS 고정 가능
- 동일 기간에 CFS/OFS가 모두 존재하면 모델 메타에 “선택된 fs_div”를 기록하고 UI에 노출

8.4 재무제표 선택(sj_div)
- 최소 요구:
  - BS(재무상태표)
  - IS(손익계산서) 또는 CIS(포괄손익계산서) 중 하나(우선순위 정책 명시)
  - CF(현금흐름표)
- 우선순위 예시:
  - 손익: CIS가 존재하면 CIS 사용, 없으면 IS 사용(또는 반대 정책을 옵션화)

8.5 표준 라인아이템 매핑(정규화)
- 계정(account_nm/account_id)은 회사/연도별로 표현이 달라질 수 있으므로, “표준 라인아이템 사전(mapping dictionary)”을 둔다.
- 매핑 전략(권장):
  - 1차: account_id 기반(표준계정ID가 있는 경우)
  - 2차: account_nm 텍스트 기반(동의어/정규식)
  - 3차: sj_div + ord + 계층(account_detail) 기반 보정
- 매핑 결과가 불확실한 항목은:
  - (a) “Unmapped”로 남기고 UI에서 매핑 후보를 제안하거나
  - (b) 룰 버전 업데이트 시 재생성 가능해야 한다(rule_version)

8.6 데이터 품질/검증
- BS 기본 검증: 자산 = 부채 + 자본(가능한 경우)
- CF/IS 연결 검증(가능한 범위): 당기순이익 ↔ 영업활동현금흐름 조정 항목 존재 여부 등
- 통화/단위: currency 필드 보존, 숫자 파싱 시 콤마 제거/결측 처리 규칙 명시
- 결측 처리:
  - 특정 statement가 누락되면 모델 생성 실패가 아니라 “부분 성공 + 누락 리포트”로 처리(옵션으로 hard-fail 가능)

9) 운영/관찰(Observability) 요구
- 각 모델 결과는 “어떤 Raw 호출(run_id, rcept_no, reprt_code, fs_div)”에 의해 만들어졌는지 추적 가능해야 한다.
- DART 오류코드(status)와 message를 표준화하여 저장/표시한다.
- 레이트리밋/요청제한(020 등) 발생 시:
  - 자동 백오프 + 큐 지연 + 관리자 알림(로그) 정책을 둔다.

10) 테스트 요구
- 단위 테스트:
  - corpCode ZIP → XML 파싱 정확성
  - fnltt 응답 row → 숫자 파싱/기간 매핑/statement 구분
  - 라인아이템 매핑 룰 테스트(룰 버전 고정)
- 통합 테스트:
  - 특정 샘플 corp_code/stock_code로 end-to-end(수집→raw→fact→model) 검증
- 회귀 테스트:
  - 동일 입력(stock_code/options)에서 rule_version이 동일하면 같은 결과가 재현되는지 확인

11) 구현 우선순위(권장 로드맵)
P0 (필수 MVP)
- corpCode 동기화 + stock_code→corp_code 매핑
- fnlttSinglAcntAll 기반 Raw 적재 + fact 변환 + 3-Statement(연간 중심)
- Job/Status API + UI 기본 화면

P1
- 분기/누적 금액 처리 고도화(quarterly 모델)
- 공시 list 메타 적재 및 rcept_no 추적 강화
- 매핑 사전/룰 버전 관리 UI(간단한 관리자 화면)

P2
- document 원문 ZIP 저장(감사 강화)
- XBRL/주석/지표 계산 확장
- 회사간 비교/시나리오 모델링 기능 확장
